#include <stdio.h>
#include <malloc.h>

// In case of a wrong input we have to notice that and free all the arrays we have
void wrongInput ( int ** array_of_id, int ** array_of_unique_id )
{
    printf ( "Nespravny vstup.\n" );
    free ( * array_of_unique_id );
    free ( * array_of_id );
}

// This function calculates the number of unique id in given interval
void numberOfUniqueAccesses ( int from, int to, int * array_of_id )
{
    int count_unique_id = 0;
    int number_of_id_to_search = to - from;
    // In case we have only one id between "from" and "to" positions - given interval
    if ( number_of_id_to_search == 0 )
        printf ( "> 1 / 1\n" );
    // counting how many unique id we have between from and to
    else
    {
        // the array for getting information how many unique users will be from position A to position B
        char * array_for_interval = ( char * ) calloc ( 100000, sizeof ( char ) );
        number_of_id_to_search ++;
        // this cycle counts the number of unique id in the given interval
        for ( int i = 0 ; i < number_of_id_to_search ; i++ )
        {
            // In case of zero we have one more unique id
            if ( array_for_interval [ array_of_id [ from + i ] ] == 0 )
            {
                array_for_interval [ array_of_id [ from + i ] ] ++;
                count_unique_id  ++;
            }
        }
        free ( array_for_interval );
        printf ( "> %d / %d\n", count_unique_id , number_of_id_to_search );
    }
}

// This function gets the interval for searching unique id
int uniqueAccesses ( int * number_of_accesses, int * array_of_id )
{
    int from = 0, to = 0;
    if ( scanf ( "%d %d ", &from, &to )  != 2 || from < 0 || to < from || to >= ( * number_of_accesses ) )
        return 0;
    numberOfUniqueAccesses ( from, to, array_of_id );
    return 1;
}

// This function adds a user to the array of users from the correct input
// and prints the number of accesses for each user
int newAccess ( int ** array_of_id, int ** array_of_unique_id, int * number_of_accesses )
{
    int id = 0;

    if ( scanf ( "%d ", &id) != 1 || id < 0 || id > 99999 || * number_of_accesses > 999999 )
    {
        return 0;
    }
    ( * array_of_id ) [ * number_of_accesses ] = id;
    ( * number_of_accesses ) ++;
    if ( ( * array_of_unique_id ) [ id ] == 0 )
    {
        printf ( "> prvni navsteva\n" );
        ( * array_of_unique_id ) [ id ] ++;
    } else
    {
        ( * array_of_unique_id ) [ id ] ++;
        printf ( "> navsteva #%d\n", ( * array_of_unique_id ) [ id ] );
    }
    return 1;
}

int main ( void )
{
    printf ( "Pozadavky:\n" );
    char sign;
    // for the need of controlling the amount of accesses that must be smaller than 1 000 000
    int number_of_accesses = 0;
    // receiving the first sign from the input: '+' for access or '?' to determine unique id of users
    char input = scanf ( "%c ", & sign);
    // the array for saving all the accesses from the input
    int * array_of_id = ( int * ) calloc ( 1000000, sizeof ( int ) );
    // the array for saving information about number of entry for every user
    int * array_of_unique_id = ( int * ) calloc ( 99999, sizeof ( int ) );
    // receiving information from the input while it is not the end of file or an error
    while ( input != EOF )
    {
        if ( sign == '+' )
        {
            if ( ! newAccess ( & array_of_id, & array_of_unique_id, & number_of_accesses ) )
            {
                wrongInput ( & array_of_id, & array_of_unique_id );
                return 0;
            }

        } else if ( sign == '?' )
        {
            if ( ! uniqueAccesses ( & number_of_accesses, array_of_id ) )
            {
                wrongInput ( & array_of_id, & array_of_unique_id );
                return 0;
            }
        } else
        {
            wrongInput ( & array_of_id, & array_of_unique_id );
            return 0;
        }
        input = scanf ( "%c ", & sign );
    }
    free ( array_of_unique_id );
    free ( array_of_id );
    return 1;
}
